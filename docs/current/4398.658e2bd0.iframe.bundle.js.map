{"version":3,"file":"4398.658e2bd0.iframe.bundle.js","mappings":";AA0BA;AAIA;AAAA;AA4ZA;AACA;AAwcA","sources":["webpack://@admiral-ds/react-ui/./node_modules/@maskito/core/index.esm.js"],"sourcesContent":["function getContentEditableSelection(element) {\n    const { anchorOffset = 0, focusOffset = 0 } = element.ownerDocument.getSelection() || {};\n    const from = Math.min(anchorOffset, focusOffset);\n    const to = Math.max(anchorOffset, focusOffset);\n    return [from, to];\n}\n\nfunction setContentEditableSelection(element, [from, to]) {\n    var _a, _b, _c, _d;\n    const document = element.ownerDocument;\n    const range = document.createRange();\n    range.setStart(element.firstChild || element, Math.min(from, (_b = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0));\n    range.setEnd(element.lastChild || element, Math.min(to, (_d = (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0));\n    const selection = document.getSelection();\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n\nclass ContentEditableAdapter {\n    constructor(element) {\n        this.element = element;\n        this.maxLength = Infinity;\n    }\n    get value() {\n        return this.element.innerText.replace(/\\n\\n$/, '\\n');\n    }\n    set value(value) {\n        // Setting into innerHTML of element with `white-space: pre;` style\n        this.element.innerHTML = value.replace(/\\n$/, '\\n\\n');\n    }\n    get selectionStart() {\n        return getContentEditableSelection(this.element)[0];\n    }\n    get selectionEnd() {\n        return getContentEditableSelection(this.element)[1];\n    }\n    setSelectionRange(from, to) {\n        setContentEditableSelection(this.element, [from !== null && from !== void 0 ? from : 0, to !== null && to !== void 0 ? to : 0]);\n    }\n    select() {\n        this.setSelectionRange(0, this.value.length);\n    }\n}\nfunction maskitoAdaptContentEditable(element) {\n    const adapter = new ContentEditableAdapter(element);\n    return new Proxy(element, {\n        get(target, prop) {\n            if (prop in adapter) {\n                return adapter[prop];\n            }\n            const nativeProperty = target[prop];\n            return typeof nativeProperty === 'function'\n                ? nativeProperty.bind(target)\n                : nativeProperty;\n        },\n        // eslint-disable-next-line @typescript-eslint/max-params\n        set(target, prop, val, receiver) {\n            return Reflect.set(prop in adapter ? adapter : target, prop, val, receiver);\n        },\n    });\n}\n\nconst MASKITO_DEFAULT_ELEMENT_PREDICATE = (e) => e.isContentEditable\n    ? maskitoAdaptContentEditable(e)\n    : e.querySelector('input,textarea') ||\n        e;\n\nconst MASKITO_DEFAULT_OPTIONS = {\n    mask: /^.*$/,\n    preprocessors: [],\n    postprocessors: [],\n    plugins: [],\n    overwriteMode: 'shift',\n};\n\nclass MaskHistory {\n    constructor() {\n        this.now = null;\n        this.past = [];\n        this.future = [];\n    }\n    undo() {\n        const state = this.past.pop();\n        if (state && this.now) {\n            this.future.push(this.now);\n            this.updateElement(state, 'historyUndo');\n        }\n    }\n    redo() {\n        const state = this.future.pop();\n        if (state && this.now) {\n            this.past.push(this.now);\n            this.updateElement(state, 'historyRedo');\n        }\n    }\n    updateHistory(state) {\n        if (!this.now) {\n            this.now = state;\n            return;\n        }\n        const isValueChanged = this.now.value !== state.value;\n        const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n        if (!isValueChanged && !isSelectionChanged) {\n            return;\n        }\n        if (isValueChanged) {\n            this.past.push(this.now);\n            this.future = [];\n        }\n        this.now = state;\n    }\n    updateElement(state, inputType) {\n        this.now = state;\n        this.updateElementState(state, { inputType, data: null });\n    }\n}\n\nfunction areElementValuesEqual(sampleState, ...states) {\n    return states.every(({ value }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n    return states.every(({ value, selection }) => value === sampleState.value &&\n        selection[0] === sampleState.selection[0] &&\n        selection[1] === sampleState.selection[1]);\n}\n\nfunction applyOverwriteMode({ value, selection }, newCharacters, mode) {\n    const [from, to] = selection;\n    const computedMode = typeof mode === 'function' ? mode({ value, selection }) : mode;\n    return {\n        value,\n        selection: computedMode === 'replace'\n            ? [from, Math.max(from + newCharacters.length, to)]\n            : [from, to],\n    };\n}\n\nfunction isFixedCharacter(char) {\n    return typeof char === 'string';\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n    let leadingFixedCharacters = '';\n    for (let i = validatedValuePart.length; i < mask.length; i++) {\n        const charConstraint = mask[i] || '';\n        const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n        if (!isFixedCharacter(charConstraint) ||\n            (charConstraint === newCharacter && !isInitiallyExisted)) {\n            return leadingFixedCharacters;\n        }\n        leadingFixedCharacters += charConstraint;\n    }\n    return leadingFixedCharacters;\n}\n\nfunction validateValueWithMask(value, maskExpression) {\n    if (Array.isArray(maskExpression)) {\n        return (value.length === maskExpression.length &&\n            Array.from(value).every((char, i) => {\n                const charConstraint = maskExpression[i] || '';\n                return isFixedCharacter(charConstraint)\n                    ? char === charConstraint\n                    : char.match(charConstraint);\n            }));\n    }\n    return maskExpression.test(value);\n}\n\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n    let maskedFrom = null;\n    let maskedTo = null;\n    const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n        const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n        const newValidatedChars = validatedCharacters + leadingCharacters;\n        const charConstraint = mask[newValidatedChars.length] || '';\n        if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n            maskedFrom = newValidatedChars.length;\n        }\n        if (maskedTo === null && charIndex >= elementState.selection[1]) {\n            maskedTo = newValidatedChars.length;\n        }\n        if (isFixedCharacter(charConstraint)) {\n            return newValidatedChars + charConstraint;\n        }\n        if (char.match(charConstraint)) {\n            return newValidatedChars + char;\n        }\n        return leadingCharacters.startsWith(char)\n            ? newValidatedChars\n            : validatedCharacters;\n    }, '');\n    const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n    return {\n        value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask)\n            ? maskedValue + trailingFixedCharacters\n            : maskedValue,\n        selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length],\n    };\n}\n\nfunction guessValidValueByRegExp({ value, selection }, maskRegExp) {\n    const [from, to] = selection;\n    let newFrom = from;\n    let newTo = to;\n    const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n        const newPossibleValue = validatedValuePart + char;\n        if (from === i) {\n            newFrom = validatedValuePart.length;\n        }\n        if (to === i) {\n            newTo = validatedValuePart.length;\n        }\n        return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n    }, '');\n    return {\n        value: validatedValue,\n        selection: [\n            Math.min(newFrom, validatedValue.length),\n            Math.min(newTo, validatedValue.length),\n        ],\n    };\n}\n\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n    if (validateValueWithMask(elementState.value, mask)) {\n        return elementState;\n    }\n    const { value, selection } = Array.isArray(mask)\n        ? guessValidValueByPattern(elementState, mask, initialElementState)\n        : guessValidValueByRegExp(elementState, mask);\n    return {\n        selection,\n        value: Array.isArray(mask) ? value.slice(0, mask.length) : value,\n    };\n}\n\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n    if (!Array.isArray(mask)) {\n        return initialElementState;\n    }\n    const [from, to] = initialElementState.selection;\n    const selection = [];\n    const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n        const charConstraint = mask[i] || '';\n        if (i === from) {\n            selection.push(rawValue.length);\n        }\n        if (i === to) {\n            selection.push(rawValue.length);\n        }\n        return isFixedCharacter(charConstraint) && charConstraint === char\n            ? rawValue\n            : rawValue + char;\n    }, '');\n    if (selection.length < 2) {\n        selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n    }\n    return {\n        value: unmaskedValue,\n        selection: [selection[0], selection[1]],\n    };\n}\n\nclass MaskModel {\n    constructor(initialElementState, maskOptions) {\n        this.maskOptions = maskOptions;\n        this.unmaskInitialState = { value: '', selection: [0, 0] };\n        this.value = '';\n        this.selection = [0, 0];\n        const expression = this.getMaskExpression(initialElementState);\n        const { value, selection } = calibrateValueByMask(initialElementState, expression);\n        this.unmaskInitialState = removeFixedMaskCharacters({ value, selection }, expression);\n        this.value = value;\n        this.selection = selection;\n    }\n    addCharacters(newCharacters) {\n        const { value, selection, maskOptions } = this;\n        const initialElementState = { value, selection };\n        const { selection: [from, to], } = applyOverwriteMode(initialElementState, newCharacters, maskOptions.overwriteMode);\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + newCharacters + value.slice(to),\n            selection: [from + newCharacters.length, from + newCharacters.length],\n        });\n        const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(this.unmaskInitialState, newCharacters, maskOptions.overwriteMode).selection;\n        const newUnmaskedLeadingValuePart = this.unmaskInitialState.value.slice(0, unmaskedFrom) + newCharacters;\n        const newCaretIndex = newUnmaskedLeadingValuePart.length;\n        const maskedElementState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart +\n                this.unmaskInitialState.value.slice(unmaskedTo),\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const prevLeadingPart = value.slice(0, from);\n        const newLeadingPartState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart,\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const isInvalidCharsInsertion = newLeadingPartState.value === prevLeadingPart ||\n            (newLeadingPartState.value.length < prevLeadingPart.length &&\n                removeFixedMaskCharacters(newLeadingPartState, maskExpression).value ===\n                    this.unmaskInitialState.value.slice(0, unmaskedFrom));\n        if (isInvalidCharsInsertion ||\n            areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n        ) {\n            throw new Error('Invalid mask value');\n        }\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    deleteCharacters() {\n        const [from, to] = this.selection;\n        if (from === to || !to) {\n            return;\n        }\n        const { value } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + value.slice(to),\n            selection: [from, from],\n        });\n        const initialElementState = { value};\n        const [unmaskedFrom, unmaskedTo] = this.unmaskInitialState.selection;\n        const newUnmaskedValue = this.unmaskInitialState.value.slice(0, unmaskedFrom) +\n            this.unmaskInitialState.value.slice(unmaskedTo);\n        const maskedElementState = calibrateValueByMask({ value: newUnmaskedValue, selection: [unmaskedFrom, unmaskedFrom] }, maskExpression, initialElementState);\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    getMaskExpression(elementState) {\n        const { mask } = this.maskOptions;\n        return typeof mask === 'function' ? mask(elementState) : mask;\n    }\n}\n\nclass EventListener {\n    constructor(element) {\n        this.element = element;\n        this.listeners = [];\n    }\n    listen(eventType, fn, options) {\n        const untypedFn = fn;\n        this.element.addEventListener(eventType, untypedFn, options);\n        this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn, options));\n    }\n    destroy() {\n        this.listeners.forEach((stopListen) => stopListen());\n    }\n}\n\nconst HotkeyModifier = {\n    CTRL: 1 << 0,\n    ALT: 1 << 1,\n    SHIFT: 1 << 2,\n    META: 1 << 3,\n};\n// TODO add variants that can be processed correctly\nconst HotkeyCode = {\n    Y: 89,\n    Z: 90,\n};\n/**\n * Checks if the passed keyboard event match the required hotkey.\n *\n * @example\n * input.addEventListener('keydown', (event) => {\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\n *         // redo hotkey pressed\n *     }\n * })\n *\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\n * {@link HotkeyModifier modifiers} have been pressed\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n    return (event.ctrlKey === !!(modifiers & HotkeyModifier.CTRL) &&\n        event.altKey === !!(modifiers & HotkeyModifier.ALT) &&\n        event.shiftKey === !!(modifiers & HotkeyModifier.SHIFT) &&\n        event.metaKey === !!(modifiers & HotkeyModifier.META) &&\n        /**\n         * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\n         * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\n         * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\n         */\n        event.keyCode === hotkeyCode);\n}\n\nfunction isRedo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Y) || // Windows\n        isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META | HotkeyModifier.SHIFT, HotkeyCode.Z) // macOS & iOS\n    );\n}\nfunction isUndo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META, HotkeyCode.Z) // macOS & iOS\n    );\n}\n\n/**\n * Sets value to element, and dispatches input event\n * if you passed ELementState, it also sets selection range\n *\n * @example\n * maskitoUpdateElement(input, newValue);\n * maskitoUpdateElement(input, elementState);\n *\n * @see {@link https://github.com/taiga-family/maskito/issues/804 issue}\n *\n * @return void\n */\nfunction maskitoUpdateElement(element, valueOrElementState) {\n    var _a;\n    const initialValue = element.value;\n    if (typeof valueOrElementState === 'string') {\n        element.value = valueOrElementState;\n    }\n    else {\n        const [from, to] = valueOrElementState.selection;\n        element.value = valueOrElementState.value;\n        if (element.matches(':focus')) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    if (element.value !== initialValue) {\n        element.dispatchEvent(new Event('input', \n        /**\n         * React handles this event only on bubbling phase\n         *\n         * here is the list of events that are processed in the capture stage, others are processed in the bubbling stage\n         * https://github.com/facebook/react/blob/cb2439624f43c510007f65aea5c50a8bb97917e4/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L222\n         */\n        { bubbles: true }));\n    }\n}\n\nfunction getLineSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const nearestBreak = isForward\n        ? value.slice(from).indexOf('\\n') + 1 || value.length\n        : value.slice(0, to).lastIndexOf('\\n') + 1;\n    const selectFrom = isForward ? from : nearestBreak;\n    const selectTo = isForward ? nearestBreak : to;\n    return [selectFrom, selectTo];\n}\n\nfunction getNotEmptySelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n    return notEmptySelection.map((x) => Math.min(Math.max(x, 0), value.length));\n}\n\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    if (isForward) {\n        const valueAfterSelectionStart = value.slice(from);\n        const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [\n            '',\n        ];\n        const nearestWordEndIndex = valueAfterSelectionStart\n            .trimStart()\n            .search(SPACE_REG);\n        return [\n            from,\n            nearestWordEndIndex !== -1\n                ? from + leadingSpaces.length + nearestWordEndIndex\n                : value.length,\n        ];\n    }\n    const valueBeforeSelectionEnd = value.slice(0, to);\n    const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n    const selectedWordLength = valueBeforeSelectionEnd\n        .trimEnd()\n        .split('')\n        .reverse()\n        .findIndex((char) => SPACE_REG.exec(char));\n    return [\n        selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0,\n        to,\n    ];\n}\n\n/* eslint-disable @typescript-eslint/no-restricted-types */\n/**\n * @internal\n */\nfunction maskitoPipe(processors = []) {\n    return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => (Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs))), initialData);\n}\n\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n    const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n    const preprocessor = maskitoPipe(options.preprocessors);\n    const postprocessor = maskitoPipe(options.postprocessors);\n    const initialElementState = typeof valueOrState === 'string'\n        ? { value: valueOrState, selection: [0, 0] }\n        : valueOrState;\n    const { elementState } = preprocessor({ elementState: initialElementState, data: '' }, 'validation');\n    const maskModel = new MaskModel(elementState, options);\n    const { value, selection } = postprocessor(maskModel, initialElementState);\n    return typeof valueOrState === 'string' ? value : { value, selection };\n}\n\n/**\n * All `input` events with `inputType=deleteContentBackward` always follows `beforeinput` event with the same `inputType`.\n * If `beforeinput[inputType=deleteContentBackward]` is prevented, subsequent `input[inputType=deleteContentBackward]` is prevented too.\n * There is an exception – Android devices with Microsoft SwiftKey Keyboard in Mobile Chrome.\n * These devices ignores `preventDefault` for `beforeinput` event if Backspace is pressed.\n * @see https://github.com/taiga-family/maskito/issues/2135#issuecomment-2980729647\n * ___\n * TODO: track Chromium bug report and delete this plugin after bug fix\n * https://issues.chromium.org/issues/40885402\n */\nfunction createBrokenDefaultPlugin() {\n    return (element) => {\n        const eventListener = new EventListener(element);\n        let isVirtualAndroidKeyboard = false;\n        let beforeinputEvent;\n        let value = element.value;\n        eventListener.listen('keydown', ({ key }) => {\n            isVirtualAndroidKeyboard = key === 'Unidentified';\n        });\n        eventListener.listen('beforeinput', (event) => {\n            beforeinputEvent = event;\n            value = element.value;\n        });\n        eventListener.listen('input', (event) => {\n            if (isVirtualAndroidKeyboard &&\n                beforeinputEvent.defaultPrevented &&\n                beforeinputEvent.inputType === 'deleteContentBackward' &&\n                event.inputType === 'deleteContentBackward') {\n                element.value = value;\n            }\n        }, { capture: true });\n        return () => eventListener.destroy();\n    };\n}\n\nfunction maskitoChangeEventPlugin() {\n    return (element) => {\n        if (element.isContentEditable) {\n            return;\n        }\n        let value = element.value;\n        const valueListener = () => {\n            value = element.value;\n        };\n        const blurListener = () => {\n            if (element.value !== value) {\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n        };\n        element.addEventListener('focus', valueListener);\n        element.addEventListener('change', valueListener);\n        element.addEventListener('blur', blurListener);\n        return () => {\n            element.removeEventListener('focus', valueListener);\n            element.removeEventListener('change', valueListener);\n            element.removeEventListener('blur', blurListener);\n        };\n    };\n}\n\nconst SPACE = ' ';\n/**\n * 1. Android user (with G-board keyboard or similar) presses 1st space\n * ```\n * {type: \"beforeinput\", data: \" \", inputType: \"insertText\"}\n * ```\n * 2. User presses 2nd space\n * ```\n * // Android tries to delete previously inserted space\n * {type: \"beforeinput\", inputType: \"deleteContentBackward\"}\n * {type: \"beforeinput\", data: \". \", inputType: \"insertText\"}\n * ```\n * ---------\n * 1. MacOS user presses 1st space\n * ```\n * {type: \"beforeinput\", data: \" \", inputType: \"insertText\"}\n * ```\n * 2. User presses 2nd space\n * ```\n * // MacOS automatically run `element.setSelectionRange(indexBeforeSpace, indexAfterSpace)` and then\n * {type: \"beforeinput\", data: \". \", inputType: \"insertText\"}\n * ```\n * ---------\n * @see https://github.com/taiga-family/maskito/issues/2023\n */\nfunction createDoubleSpacePlugin() {\n    let prevValue = '';\n    let prevCaretIndex = 0;\n    let prevEvent = null;\n    let prevRejectedSpace = false;\n    return (element) => {\n        const eventListener = new EventListener(element);\n        eventListener.listen('beforeinput', (event) => {\n            var _a, _b;\n            const { value, selectionStart, selectionEnd } = element;\n            const rejectedSpace = (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.inputType) === 'insertText' &&\n                (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.data) === SPACE &&\n                !value.slice(0, Number(selectionEnd)).endsWith(SPACE);\n            if (event.inputType === 'insertText' && event.data === `.${SPACE}`) {\n                if ((prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.inputType) === 'deleteContentBackward' &&\n                    prevRejectedSpace) {\n                    // Android\n                    element.value = prevValue;\n                    (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, prevCaretIndex, prevCaretIndex);\n                }\n                else if (rejectedSpace) {\n                    // Mac OS\n                    (_b = element.setSelectionRange) === null || _b === void 0 ? void 0 : _b.call(element, selectionStart, selectionStart);\n                }\n            }\n            prevRejectedSpace = rejectedSpace;\n            prevEvent = event;\n            prevValue = value;\n            prevCaretIndex = Number((rejectedSpace ? prevCaretIndex : selectionEnd) === value.length\n                ? selectionEnd\n                : selectionStart);\n        });\n        return () => eventListener.destroy();\n    };\n}\n\nfunction maskitoInitialCalibrationPlugin(customOptions) {\n    return (element, options) => {\n        var _a, _b;\n        const from = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n        const to = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n        maskitoUpdateElement(element, {\n            value: maskitoTransform(element.value, customOptions || options),\n            selection: [from, to],\n        });\n    };\n}\n\nfunction maskitoStrictCompositionPlugin() {\n    return (element, maskitoOptions) => {\n        const listener = (event) => {\n            var _a, _b;\n            if (event.inputType !== 'insertCompositionText') {\n                return;\n            }\n            const selection = [\n                (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0,\n                (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0,\n            ];\n            const elementState = {\n                selection,\n                value: element.value,\n            };\n            const validatedState = maskitoTransform(elementState, maskitoOptions);\n            if (!areElementStatesEqual(elementState, validatedState)) {\n                event.preventDefault();\n                maskitoUpdateElement(element, validatedState);\n            }\n        };\n        element.addEventListener('input', listener);\n        return () => element.removeEventListener('input', listener);\n    };\n}\n\nconst BUILT_IN_PLUGINS = [createDoubleSpacePlugin(), createBrokenDefaultPlugin()];\nclass Maskito extends MaskHistory {\n    constructor(element, maskitoOptions) {\n        super();\n        this.element = element;\n        this.maskitoOptions = maskitoOptions;\n        this.isTextArea = this.element.nodeName === 'TEXTAREA';\n        this.eventListener = new EventListener(this.element);\n        this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n        this.upcomingElementState = null;\n        this.preprocessor = maskitoPipe(this.options.preprocessors);\n        this.postprocessor = maskitoPipe(this.options.postprocessors);\n        this.teardowns = this.options.plugins\n            .concat(BUILT_IN_PLUGINS)\n            .map((plugin) => plugin(this.element, this.options));\n        this.updateHistory(this.elementState);\n        this.eventListener.listen('keydown', (event) => {\n            if (isRedo(event)) {\n                event.preventDefault();\n                return this.redo();\n            }\n            if (isUndo(event)) {\n                event.preventDefault();\n                return this.undo();\n            }\n        });\n        this.eventListener.listen('beforeinput', (event) => {\n            var _a, _b, _c;\n            const isForward = event.inputType.includes('Forward');\n            this.updateHistory(this.elementState);\n            switch (event.inputType) {\n                case 'deleteByCut':\n                case 'deleteContentBackward':\n                case 'deleteContentForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getNotEmptySelection(this.elementState, isForward),\n                    });\n                case 'deleteHardLineBackward':\n                case 'deleteHardLineForward':\n                case 'deleteSoftLineBackward':\n                case 'deleteSoftLineForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getLineSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'deleteWordBackward':\n                case 'deleteWordForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getWordSelection(this.elementState, isForward),\n                    });\n                case 'historyRedo':\n                    event.preventDefault();\n                    return this.redo();\n                // historyUndo/historyRedo will not be triggered if value was modified programmatically\n                case 'historyUndo':\n                    event.preventDefault();\n                    return this.undo();\n                case 'insertCompositionText':\n                    return; // will be handled inside `compositionend` event\n                case 'insertLineBreak':\n                case 'insertParagraph':\n                    return this.handleEnter(event);\n                case 'insertReplacementText':\n                    /**\n                     * According {@link https://www.w3.org/TR/input-events-2 W3C specification}:\n                     * > `insertReplacementText` – insert or replace existing text by means of a spell checker,\n                     * > auto-correct, writing suggestions or similar.\n                     * ___\n                     * Firefox emits `insertReplacementText` event for its suggestion/autofill and for spell checker.\n                     * However, it is impossible to detect which part of the textfield value is going to be replaced\n                     * (`selectionStart` and `selectionEnd` just equal to the last caret position).\n                     * ___\n                     * Chrome does not fire `beforeinput` event for its suggestion/autofill.\n                     * It emits only `input` event with `inputType` and `data` set to `undefined`.\n                     * ___\n                     * All these browser limitations make us to validate the result value later in `input` event.\n                     */\n                    return;\n                case 'insertFromDrop':\n                case 'insertFromPaste':\n                case 'insertText':\n                default:\n                    return this.handleInsert(event, (_c = (_a = event.data) !== null && _a !== void 0 ? _a : \n                    // `event.data` for `contentEditable` is always `null` for paste/drop events\n                    (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) !== null && _c !== void 0 ? _c : '');\n            }\n        });\n        this.eventListener.listen('input', () => {\n            if (this.upcomingElementState &&\n                !areElementStatesEqual(this.upcomingElementState, this.elementState)) {\n                this.updateElementState(this.upcomingElementState);\n            }\n            this.upcomingElementState = null;\n        }, { capture: true });\n        this.eventListener.listen('input', ({ inputType }) => {\n            if (inputType === 'insertCompositionText') {\n                return; // will be handled inside `compositionend` event\n            }\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n        this.eventListener.listen('compositionend', () => {\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n    }\n    destroy() {\n        this.eventListener.destroy();\n        this.teardowns.forEach((teardown) => teardown === null || teardown === void 0 ? void 0 : teardown());\n    }\n    updateElementState({ value, selection }, eventInit) {\n        const initialValue = this.elementState.value;\n        this.updateValue(value);\n        this.updateSelectionRange(selection);\n        if (eventInit && initialValue !== value) {\n            this.dispatchInputEvent(eventInit);\n        }\n    }\n    get elementState() {\n        const { value, selectionStart, selectionEnd } = this.element;\n        return {\n            value,\n            selection: [selectionStart !== null && selectionStart !== void 0 ? selectionStart : 0, selectionEnd !== null && selectionEnd !== void 0 ? selectionEnd : 0],\n        };\n    }\n    get maxLength() {\n        const { maxLength } = this.element;\n        return maxLength === -1 ? Infinity : maxLength;\n    }\n    updateSelectionRange([from, to]) {\n        var _a;\n        const { element } = this;\n        if (element.matches(':focus') &&\n            (element.selectionStart !== from || element.selectionEnd !== to)) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    updateValue(value) {\n        /**\n         * Don't \"disturb\" unnecessarily `value`-setter\n         * (i.e. it breaks React controlled input behavior)\n         */\n        if (this.element.value !== value || this.element.isContentEditable) {\n            this.element.value = value;\n        }\n    }\n    ensureValueFitsMask() {\n        this.updateElementState(maskitoTransform(this.elementState, this.options), {\n            inputType: 'insertText',\n            data: null,\n        });\n    }\n    dispatchInputEvent(eventInit = {\n        inputType: 'insertText',\n        data: null,\n    }) {\n        if (globalThis.InputEvent) {\n            this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), { bubbles: true, cancelable: false })));\n        }\n    }\n    handleDelete({ event, selection, isForward, }) {\n        const initialState = {\n            value: this.elementState.value,\n            selection,\n        };\n        const { elementState } = this.preprocessor({\n            elementState: initialState,\n            data: '',\n        }, isForward ? 'deleteForward' : 'deleteBackward');\n        const maskModel = new MaskModel(elementState, this.options);\n        maskModel.deleteCharacters();\n        const newElementState = this.postprocessor(maskModel, initialState);\n        if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n            const [from, to] = elementState.selection;\n            event.preventDefault();\n            // User presses Backspace/Delete for the fixed value\n            return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n        }\n        this.upcomingElementState = newElementState;\n    }\n    handleInsert(event, data) {\n        const { options, maxLength, elementState: initialElementState } = this;\n        const [from, to] = initialElementState.selection;\n        const { elementState, data: insertedText = data } = this.preprocessor({\n            data,\n            elementState: initialElementState,\n        }, 'insert');\n        const maskModel = new MaskModel(elementState, options);\n        try {\n            maskModel.addCharacters(insertedText);\n        }\n        catch (_a) {\n            return event.preventDefault();\n        }\n        this.upcomingElementState = this.clampState(this.postprocessor(maskModel, initialElementState));\n        /**\n         * When textfield value length is already equal to attribute `maxlength`,\n         * pressing any key (even with valid value) does not emit `input` event\n         * (except to the case when user replaces some characters by selection).\n         */\n        const noInputEventDispatch = initialElementState.value.length >= maxLength && from === to;\n        if (noInputEventDispatch) {\n            if (options.overwriteMode === 'replace' &&\n                !areElementStatesEqual(this.upcomingElementState, initialElementState)) {\n                this.dispatchInputEvent({ inputType: 'insertText', data });\n            }\n            else {\n                /**\n                 * This `beforeinput` event will not be followed by `input` event –\n                 * clear computed state to avoid any possible side effect\n                 * for new possible `input` event without preceding `beforeinput` event\n                 * (e.g. browser autofill, `document.execCommand('delete')` etc.)\n                 */\n                this.upcomingElementState = null;\n            }\n        }\n    }\n    handleEnter(event) {\n        if (this.isTextArea || this.element.isContentEditable) {\n            this.handleInsert(event, '\\n');\n        }\n    }\n    clampState({ value, selection }) {\n        const [from, to] = selection;\n        const max = this.maxLength;\n        return {\n            value: value.slice(0, max),\n            selection: [Math.min(from, max), Math.min(to, max)],\n        };\n    }\n}\n\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoAdaptContentEditable, maskitoChangeEventPlugin, maskitoInitialCalibrationPlugin, maskitoPipe, maskitoStrictCompositionPlugin, maskitoTransform, maskitoUpdateElement };\n"],"names":[],"sourceRoot":""}